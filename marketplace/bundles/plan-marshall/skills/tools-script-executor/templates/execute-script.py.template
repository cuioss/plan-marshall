#!/usr/bin/env python3
"""
Universal script executor with embedded path mappings.
Generated by /marshall-steward - DO NOT EDIT MANUALLY.

Usage: python3 .plan/execute-script.py {notation} [subcommand] [args...]

Notation format: {bundle}:{skill}:{script}

Tracing:
    --trace-plan-id <id>  Log execution to plan-specific log (stripped before passing to script)
                          Use for scripts that don't accept --plan-id themselves.
                          Scripts with --plan-id use that for both logic AND logging.

Examples:
    python3 .plan/execute-script.py planning:manage-files:manage-files add --plan-id my-plan
    python3 .plan/execute-script.py pm-dev-java:plan-marshall-plugin:maven run --targets verify
    python3 .plan/execute-script.py plan-marshall:tools-marketplace-inventory:scan-marketplace-inventory --trace-plan-id my-plan --include-descriptions
"""

import os
import subprocess
import sys
import time
from pathlib import Path

# Plan directory name - injected at generation time
# This constant enables consistent path construction across all scripts
PLAN_DIR_NAME = '{{PLAN_DIR_NAME}}'

# Import plan logging module from marketplace (named plan_logging to avoid conflict with stdlib)
sys.path.insert(0, '{{LOGGING_DIR}}')
from plan_logging import log_script_execution, cleanup_old_script_logs  # type: ignore[import-not-found]

# ============================================================================
# EMBEDDED SCRIPT MAPPINGS (Generated by plan-marshall)
# ============================================================================
SCRIPTS = {
    # {notation}: {absolute_path}
    {{SCRIPT_MAPPINGS}}
}

# Build PYTHONPATH from all unique script directories
# This allows scripts to import from any skill without path manipulation
_SCRIPT_DIRS = sorted(set(str(Path(p).parent) for p in SCRIPTS.values()))
_PYTHONPATH = ':'.join(_SCRIPT_DIRS)

# ============================================================================
# CONFIGURATION
# ============================================================================
VALIDATE_TOON = False  # Set True for strict TOON output validation

# ============================================================================
# EXECUTION LOGIC
# ============================================================================

# Scripts whose successful executions are NOT logged to prevent meta-logging noise
# (logging scripts logging themselves creates excessive noise)
SILENT_ON_SUCCESS = frozenset([
    'plan-marshall:manage-logging:manage-log',
])


def should_skip_logging(notation: str, exit_code: int) -> bool:
    """
    Determine if logging should be skipped for this execution.

    Logging scripts (like manage-log) are not logged when successful to avoid
    meta-logging noise. Errors are always logged regardless of script type.

    Args:
        notation: Script notation (e.g., 'plan-marshall:manage-logging:manage-log')
        exit_code: Script exit code (0 = success)

    Returns:
        True if logging should be skipped, False otherwise
    """
    return notation in SILENT_ON_SUCCESS and exit_code == 0


def extract_trace_plan_id(args: list[str]) -> tuple[str | None, list[str]]:
    """
    Extract --trace-plan-id from args and return cleaned args.

    --trace-plan-id is for logging only - it's stripped before passing to the script.
    Use for scripts that don't accept --plan-id themselves.

    Args:
        args: Command line arguments

    Returns:
        Tuple of (trace_plan_id or None, cleaned_args without --trace-plan-id)
    """
    trace_plan_id = None
    cleaned = []
    skip_next = False

    for i, arg in enumerate(args):
        if skip_next:
            skip_next = False
            continue
        if arg == '--trace-plan-id':
            if i + 1 < len(args):
                trace_plan_id = args[i + 1]
                skip_next = True
        elif arg.startswith('--trace-plan-id='):
            trace_plan_id = arg.split('=', 1)[1]
        else:
            cleaned.append(arg)

    return trace_plan_id, cleaned


def resolve_notation(notation: str) -> str | None:
    """Resolve notation to absolute script path."""
    # Direct lookup
    if notation in SCRIPTS:
        return SCRIPTS[notation]

    # Try with /scripts/{skill}.py suffix for compatibility
    for key, path in SCRIPTS.items():
        if key.startswith(notation) or notation in key:
            return path

    return None


def build_notation_error(notation: str) -> tuple[str, list[str]]:
    """
    Build helpful error message for invalid notation.

    Returns:
        Tuple of (error_message, suggestions)
    """
    suggestions = [key for key in sorted(SCRIPTS.keys()) if notation.lower() in key.lower()]

    # Check if this looks like a subcommand was used as script name
    parts = notation.split(':')
    if len(parts) == 3:
        prefix = f"{parts[0]}:{parts[1]}"
        possible_cmd = parts[2]
        matching_scripts = [k for k in SCRIPTS.keys() if k.startswith(prefix + ':')]
        if matching_scripts:
            correct_script = matching_scripts[0].split(':')[2]
            error_msg = (
                f"Invalid notation: '{notation}'\n"
                f"  The third part '{possible_cmd}' appears to be a subcommand, not a script name.\n"
                f"  Correct format: {prefix}:{correct_script} {possible_cmd}"
            )
            return error_msg, suggestions

    return f"Unknown notation: {notation}", suggestions


def handle_invalid_notation(notation: str, remaining_args: list[str]) -> None:
    """Handle invalid notation lookup with logging and helpful error output."""
    error_msg, suggestions = build_notation_error(notation)

    # Log the invalid lookup
    log_script_execution(
        notation=notation,
        subcommand='',
        args=remaining_args,
        exit_code=1,
        duration=0.0,
        stdout='',
        stderr=error_msg
    )

    print(f"SCRIPT_ERROR\t{notation}\t1\tUnknown notation", file=sys.stderr)
    print(f"\n{error_msg}", file=sys.stderr)
    if suggestions:
        print(f"\nAvailable scripts matching '{notation}':", file=sys.stderr)
        for key in suggestions:
            print(f"  {key}", file=sys.stderr)
    sys.exit(1)


def main():
    if len(sys.argv) < 2:
        print("Usage: execute-script.py <notation> [subcommand] [args...]", file=sys.stderr)
        print("\nNotation format: {bundle}:{skill}:{script}", file=sys.stderr)
        print("\nAvailable scripts:", file=sys.stderr)
        for notation in sorted(SCRIPTS.keys()):
            print(f"  {notation}", file=sys.stderr)
        sys.exit(1)

    notation = sys.argv[1]

    # Handle --list option
    if notation == '--list':
        for n in sorted(SCRIPTS.keys()):
            print(n)
        sys.exit(0)

    remaining_args = sys.argv[2:]

    # Extract --trace-plan-id (logging only, stripped before passing to script)
    trace_plan_id, script_args = extract_trace_plan_id(remaining_args)

    # Subcommand is first arg after stripping trace-plan-id
    subcommand = script_args[0] if script_args else ''

    script_path = resolve_notation(notation)
    if not script_path:
        handle_invalid_notation(notation, remaining_args)

    if not Path(script_path).exists():
        print(f"SCRIPT_ERROR\t{notation}\t1\tScript not found: {script_path}", file=sys.stderr)
        sys.exit(1)

    # Execute the script (with cleaned args, no --trace-plan-id)
    start = time.time()
    stdout_capture = ''
    stderr_capture = ''

    # Build environment with PYTHONPATH for cross-skill imports
    env = os.environ.copy()
    existing_pythonpath = env.get('PYTHONPATH', '')
    env['PYTHONPATH'] = _PYTHONPATH + (':' + existing_pythonpath if existing_pythonpath else '')
    # Export PLAN_DIR_NAME so scripts can use it for path construction
    # Use setdefault to respect existing value (e.g., set by test infrastructure)
    env.setdefault('PLAN_DIR_NAME', PLAN_DIR_NAME)

    try:
        # Capture output for logging (but still stream to console)
        result = subprocess.run(
            ['python3', script_path] + script_args,
            capture_output=True,
            text=True,
            env=env
        )
        exit_code = result.returncode
        stdout_capture = result.stdout
        stderr_capture = result.stderr

        # Stream output to console
        if result.stdout:
            print(result.stdout, end='')
        if result.stderr:
            print(result.stderr, end='', file=sys.stderr)

    except Exception as e:
        print(f"SCRIPT_ERROR\t{notation}\t1\t{str(e)}", file=sys.stderr)
        stderr_capture = str(e)
        exit_code = 1

    duration = time.time() - start

    # Build args for logging: inject --plan-id if trace_plan_id was provided
    # This allows log_script_execution to route to plan-specific log
    args_for_logging = script_args.copy()
    if trace_plan_id:
        args_for_logging = ['--plan-id', trace_plan_id] + args_for_logging

    # Log execution (skip for logging scripts on success to avoid meta-logging noise)
    if not should_skip_logging(notation, exit_code):
        log_script_execution(
            notation=notation,
            subcommand=subcommand,
            args=args_for_logging,
            exit_code=exit_code,
            duration=duration,
            stdout=stdout_capture if exit_code != 0 else '',
            stderr=stderr_capture if exit_code != 0 else ''
        )

    sys.exit(exit_code)

if __name__ == '__main__':
    main()
